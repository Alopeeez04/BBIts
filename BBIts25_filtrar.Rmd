---
title: "BBIts25_ filtrar"
author: "Ainhoa López"
date: "2025-12-07"
output: html_document
---
```{r}
```


```{r}
```


```{r}
suppressPackageStartupMessages({
  library(ggplot2)
  library(car)
  library(corrplot)
  library(broom)
  library(effects)
  library(pROC)
  library(dplyr)
  library(forcats)
  library(logistf)
  library(readxl)
})
```



```{r}
data <- read_excel("data_hack.xlsx")
data
```


```{r}

library(dplyr)

columnas_a_conservar <- c(
  "codigo_participante",
  "recidiva",
  "recidiva_exitus",
  "diferencia_dias_reci_exit",
  "causa_muerte",
  "f_diag",
  "fecha_de_recidi",
  "f_muerte",
  "Ultima_fecha",
  "edad",
  "imc",
  "tipo_histologico",
  "Grado",
  "valor_de_ca125",
  "ecotv_infiltsub",
  "metasta_distan",
  "libre_enferm",
  "numero_de_recid",
  "recid_super_1",
  "dx_recidiva",
  "num_recidiva",
  "loc_recidiva_r01",
  "loc_recidiva_r03",
  "loc_recidiva_r04",
  "loc_recidiva_r05",
  "loc_recidiva_r06",
  "tto_recidiva",
  "Tt_recidiva_qx",
  "otro_ttIQ_recid",
  "Reseccion_macroscopica_complet",
  "Tratamiento_RT",
  "Tratamiento_sistemico",
  "estado",
  "tto_1_quirugico",
  "fecha_qx",
  "recep_est_porcent",
  "rece_de_Ppor",
  "p53_molecular",
  "p53_ihq",
  "mut_pole",
  "beta_cateninap",
  "msh2",
  "msh6",
  "pms2",
  "mlh1",
  "estudio_genetico_r01",
  "estudio_genetico_r02",
  "estudio_genetico_r03",
  "estudio_genetico_r04",
  "estudio_genetico_r05",
  "estudio_genetico_r06",
  "Tratamiento_sistemico_realizad",
  "grupo_de_riesgo_definitivo",
  "Tributaria_a_Radioterapia",
  "asa",
  "histo_defin",
  "afectacion_linf",
  "grado_histologi",
  "tamano_tumoral",
  "AP_centinela_pelvico",
  "AP_ganPelv"
)




```


```{r}

data_reducido <- data %>% select(all_of(columnas_a_conservar))

# Fix inconsistencies between death_status and f_muerte
data_reducido <- data_reducido %>%
  mutate(
    death_status = ifelse(recidiva_exitus == 1, "Deceased", "Alive"),
    # Correction rule: trust the date
    death_status = case_when(
      !is.na(f_muerte) ~ "Deceased",
      is.na(f_muerte)  ~ "Alive"
    ),
    recidiva_exitus = ifelse(death_status == "Deceased", 1, 0)
  )

# Quick validation summary
summary_check <- data_reducido %>%
  group_by(death_status) %>%
  summarise(
    total = n(),
    missing_date = sum(is.na(f_muerte)),
    with_date = sum(!is.na(f_muerte)),
    perc_missing = round(100 * missing_date / total, 1)
  )

print(summary_check)



```

```{r}
data_limpia <- data_reducido %>%
  select(where(~ mean(is.na(.)) < 0.5)) 
```


```{r}
sapply(data_limpia, class)
nrow(data_limpia); ncol(data_limpia)

# Elegir outcome
data_rec <- data_limpia %>%
  mutate(recidiva_bin = ifelse(recidiva %in% c(0,1), recidiva, NA)) %>%
  filter(!is.na(recidiva_bin))
outcome_var <- "recidiva_bin"

#### Juntar variables con menos de 5 casos para no tener overfitting
data_rec <- data_rec %>%
  mutate(tipo_histologico_collapsed = fct_lump_min(factor(tipo_histologico), min = 5))


data_rec <- data_rec %>%
  mutate(
    recidiva_bin = factor(recidiva_bin, levels = c(0,1), labels = c("NoRecidiva","Recidiva")),
    Grado = factor(Grado, levels = c(1,2), labels = c("Bajo","Alto")),
    grado_histologi = factor(grado_histologi, levels = c(1,2), labels = c("Bajo","Alto")),
    libre_enferm = factor(libre_enferm, levels = c(0,1,2), labels = c("No","Si","Desconocido")),
    metasta_distan = factor(metasta_distan, levels = c(0,1), labels = c("No","Si")),
    Tratamiento_RT = factor(Tratamiento_RT, levels = c(0,1), labels = c("No","Si")),
    Tratamiento_sistemico = factor(Tratamiento_sistemico, levels = c(0,1), labels = c("No","Si")),
    Tributaria_a_Radioterapia = factor(Tributaria_a_Radioterapia, levels = c(0,1), labels = c("No","Si")),
    asa = factor(asa, levels = c(0,1,2,3,4,5,6),
                 labels = c("ASA1","ASA2","ASA3","ASA4","ASA5","ASA6","Desconocido")),
    afectacion_linf = factor(afectacion_linf, levels = c(0,1), labels = c("No","Si")),
    AP_centinela_pelvico = factor(AP_centinela_pelvico, levels = c(0,1,2,3,4),
                                  labels = c("pN0","pN0(i+)","pN1(mi)","pN1","pNx")),
    AP_ganPelv = factor(AP_ganPelv, levels = c(0,1,2,3),
                        labels = c("Negativo","Cels_aisladas","Micrometastasis","Macrometastasis")),
    grupo_de_riesgo_definitivo = factor(grupo_de_riesgo_definitivo, levels = c(1,2,3,4,5),
                                        labels = c("Bajo","Intermedio","Intermedio_alto","Alto","Avanzados"))
  )

tab_out <- table(data_rec[[outcome_var]])
print(tab_out)
print(round(prop.table(tab_out)*100,2))

#### Plots 
ggplot(data_rec, aes_string(x = outcome_var, fill = outcome_var)) +
  geom_bar() + ggtitle("Outcome distribution")

ggplot(data_rec, aes(x = tipo_histologico_collapsed, fill = factor(recidiva_bin))) +
  geom_bar(position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Collapsed histology vs outcome")

#### Quitar los que no nos interesan 
exclude <- c("codigo_participante","f_diag","Ultima_fecha","fecha_qx","tt_o_f_ini","tt_o_f_fin",
             "recidiva","estado","recidiva_exitus","diferencia_dias_reci_exit",
             "visita_control","fecha_de_recidi","f_muerte","causa_muerte")

candidate_vars <- setdiff(names(data_rec), c(exclude, outcome_var))

# Filtrar posibles predictores
candidate_vars <- candidate_vars[sapply(data_rec[candidate_vars], function(x) length(unique(na.omit(x))) > 1)]

#### Univariate logistic regression
univ_results <- list()
for (v in candidate_vars) {
  f <- as.formula(paste(outcome_var, "~", v))
  m <- try(glm(f, data = data_rec, family = "binomial"), silent = TRUE)
  if (inherits(m, "try-error")) next
  sm <- summary(m)
  pvals <- coef(sm)[, "Pr(>|z|)"]
  p_test <- if (length(pvals) > 1) min(pvals[-1], na.rm = TRUE) else pvals[1]
  univ_results[[v]] <- list(p = p_test)
  cat("Univariate:", v, "p(min across levels) =", signif(p_test, 4), "\n")
}

alpha <- 0.05
significant_predictors <- names(Filter(function(x) !is.na(x$p) && x$p < alpha, univ_results))
cat("Significant predictors:", paste(significant_predictors, collapse = ", "), "\n")


```

```{r, warning=FALSE}
#### Modelos multivariables con predictors con más de 1 posible outcome
sig_vars <- significant_predictors[
  sapply(data_rec[significant_predictors], function(x) length(unique(na.omit(x))) > 1)
]

# Construir la fórmula solo con estos predictors
sig_formula <- as.formula(paste(outcome_var, "~", paste(sig_vars, collapse = " + ")))

# Crear el modelo
sig_model <- glm(sig_formula, data = data_rec, family = "binomial")
summary(sig_model)

# Firth logistic regression
firth_model <- logistf(sig_formula, data = data_rec,
                       control = logistf.control(maxit = 200, maxstep = 0.5))
summary(firth_model)


```

```{r, warning=FALSE}
# Elegimos predictors basados en relevancia clínica, con muchos datos y no redundantes:

core_vars <- c(
  "Grado",
  "afectacion_linf",
  "grupo_de_riesgo_definitivo",
  "tipo_histologico_collapsed",
  "beta_cateninap"
)

data_core <- data_rec %>%
  select(recidiva_bin, all_of(core_vars)) %>%
  na.omit()

nrow(data_core)
table(data_core$recidiva_bin)

# Fórmula del modelo
core_formula <- as.formula(
  paste("recidiva_bin ~", paste(core_vars, collapse = " + "))
)

# Standard logistic regression (referencia)
core_model <- glm(core_formula, data = data_core, family = binomial)
summary(core_model)

# Firth logistic regression (modelo final)
core_model_firth <- logistf(
  core_formula,
  data = data_core,
  control = logistf.control(maxit = 300)
)

summary(core_model_firth)


# Odds ratios
firth_sum <- summary(core_model_firth)

# Tabla con los OR
or_table <- data.frame(
  Variable = names(core_model_firth$coefficients),
  OR = exp(core_model_firth$coefficients),
  CI_low = exp(core_model_firth$ci.lower),
  CI_high = exp(core_model_firth$ci.upper),
  p_value = core_model_firth$prob,
  row.names = NULL
)

or_table


# Discriminación del modelo
# Predicted probabilities
pred_prob <- predict(core_model_firth, type = "response")

# ROC
roc_obj <- suppressMessages(
  roc(
    response = as.numeric(data_core$recidiva_bin == "Recidiva"),
    predictor = pred_prob,
    levels = c(0, 1),
    direction = "<"
  )
)

plot(roc_obj, main = "ROC – NSMP Recurrence Model")
auc(roc_obj)


# Estratificación de riesgo
data_core$risk_group <- cut(
  pred_prob,
  breaks = c(0, 0.2, 0.4, 1),
  labels = c("Low", "Intermediate", "High")
)

table(data_core$risk_group, data_core$recidiva_bin)

ggplot(data_core, aes(x = risk_group, fill = recidiva_bin)) +
  geom_bar(position = "fill") +
  ylab("Proportion") +
  ggtitle("Recurrence risk by predicted risk group")


# Bootstrap AUC
set.seed(123)

auc_boot <- replicate(200, {
  idx <- sample(seq_len(nrow(data_core)), replace = TRUE)

  m <- suppressWarnings(
    logistf(
      core_formula,
      data = data_core[idx, ],
      control = logistf.control(maxit = 300)
    )
  )

  p <- predict(m, newdata = data_core[idx, ], type = "response")

  suppressMessages(
    auc(
      roc(
        as.numeric(data_core$recidiva_bin[idx] == "Recidiva"),
        p,
        levels = c(0, 1),
        direction = "<"
      )
    )
  )
})

mean(auc_boot)
quantile(auc_boot, c(0.025, 0.975))

```

```{r}
#### Cross-validated ROC/AUC 

set.seed(42)

core_vars <- c("Grado","afectacion_linf","grupo_de_riesgo_definitivo",
               "tipo_histologico_collapsed","beta_cateninap")

# Complete-case dataset
data_core <- data_rec %>%
  select(recidiva_bin, all_of(core_vars)) %>%
  na.omit()

# Ajustar los valores de la dataset como al principio
data_core <- data_core %>%
  mutate(
    recidiva_bin = factor(recidiva_bin, levels = c("NoRecidiva","Recidiva")),
    Grado = factor(Grado, levels = c("Bajo","Alto")),
    afectacion_linf = factor(afectacion_linf, levels = c("No","Si")),
    grupo_de_riesgo_definitivo = factor(grupo_de_riesgo_definitivo,
                                        levels = c("Bajo","Intermedio","Intermedio_alto","Alto","Avanzados")),
    tipo_histologico_collapsed = factor(tipo_histologico_collapsed,
                                        levels = c("1","2","Other")), # adjust to your actual collapsed levels
    beta_cateninap = factor(beta_cateninap, levels = c("0","1","2","NA")) # adjust to your coding
  )

# Folds estratificados
K <- 5
idx_no  <- which(data_core$recidiva_bin == "NoRecidiva")
idx_yes <- which(data_core$recidiva_bin == "Recidiva")

folds_no  <- split(sample(idx_no),  rep(1:K, length.out = length(idx_no)))
folds_yes <- split(sample(idx_yes), rep(1:K, length.out = length(idx_yes)))
folds <- lapply(1:K, function(k) sort(c(folds_no[[k]], folds_yes[[k]])))

# Predicciones out-of-fold
oof_pred <- rep(NA_real_, nrow(data_core))

for (k in 1:K) {
  test_idx <- folds[[k]]
  train_idx <- setdiff(seq_len(nrow(data_core)), test_idx)
  
  train_dat <- data_core[train_idx, , drop = FALSE]
  test_dat  <- data_core[test_idx,  , drop = FALSE]
  
  fml <- as.formula(paste("recidiva_bin ~", paste(core_vars, collapse = " + ")))
  fit_k <- logistf(fml, data = train_dat,
                   control = logistf.control(maxit = 200, maxstep = 0.5))
  
  oof_pred[test_idx] <- predict(fit_k, newdata = test_dat, type = "response")
}

# Compute CV ROC
roc_cv <- roc(data_core$recidiva_bin, oof_pred,
              levels = c("NoRecidiva","Recidiva"), direction = "<")
plot(roc_cv, col = "blue", main = "ROC curve (Firth, 5-fold CV)")
cat("Cross-validated AUC =", round(auc(roc_cv), 3), "\n")
```
```{r}
# Paquetes necesarios
library(dplyr)
library(imputeTS)

# Variables significativas
sig_vars <- c("Grado", "libre_enferm", "beta_cateninap", "mlh1",
              "grupo_de_riesgo_definitivo", "Tributaria_a_Radioterapia",
              "afectacion_linf", "grado_histologi", "AP_centinela_pelvico",
              "AP_ganPelv", "tipo_histologico_collapsed")

# Selección y conversión de factores a numéricos
data_sig <- data_rec %>%
  select(all_of(sig_vars)) %>%
  mutate(across(everything(), ~ as.numeric(as.factor(.))))

# Imputación de valores NA con la mediana
data_sig_imputed <- data_sig %>%
  mutate(across(everything(), ~ ifelse(is.na(.), median(., na.rm = TRUE), .)))

# PCA con escalado
pca_res <- prcomp(data_sig_imputed, scale. = TRUE)

# Eigenvalues y proporción de varianza explicada
eig_vals <- (pca_res$sdev)^2
var_explained <- eig_vals / sum(eig_vals)

# Scree plot
plot(var_explained, type = "b", xlab = "PC", ylab = "Proporción de varianza explicada",
     main = "Scree Plot")

# Varianza acumulada
plot(cumsum(var_explained), type = "b", xlab = "PC", ylab = "Varianza acumulada",
     main = "Varianza acumulada por componente")

# Crear un data frame con los resultados
varianza_df <- data.frame(
  Componente = paste0("PC", seq_along(var_explained)),
  Varianza_Explicada = round(var_explained, 4),
  Varianza_Acumulada = round(cumsum(var_explained), 4)
)

# Mostrar ordenado por varianza explicada (de mayor a menor)
varianza_df[order(-varianza_df$Varianza_Explicada), ]


# Loadings (pesos de cada variable en cada componente)
loadings <- pca_res$rotation

# Mostrar los primeros componentes (por ejemplo PC1 y PC2)
loadings_df <- data.frame(loadings[, 1:2])
print(loadings_df)

# Si quieres ordenarlos por importancia en PC1
loadings_PC1 <- sort(loadings[,1], decreasing = TRUE)
print(loadings_PC1)

# Si quieres ordenarlos por importancia en PC2
loadings_PC2 <- sort(loadings[,2], decreasing = TRUE)
print(loadings_PC2)



```

```{r}
# Extraer los loadings (pesos de cada variable en cada componente)
loadings <- pca_res$rotation

# Convertir a data frame para facilitar el manejo
loadings_df <- as.data.frame(loadings)
loadings_df$Variable <- rownames(loadings_df)

# Visualizar los pesos ordenados para PC1
loadings_PC1 <- loadings_df %>%
  select(Variable, PC1) %>%
  arrange(desc(abs(PC1)))

print(loadings_PC1)

# Visualizar los pesos ordenados para PC2
loadings_PC2 <- loadings_df %>%
  select(Variable, PC2) %>%
  arrange(desc(abs(PC2)))

print(loadings_PC2)

library(ggplot2)

# Barplot para PC1
ggplot(loadings_PC1, aes(x = reorder(Variable, abs(PC1)), y = PC1)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Contribución de variables a PC1", x = "Variable", y = "Peso (loading)")

# Barplot para PC2
ggplot(loadings_PC2, aes(x = reorder(Variable, abs(PC2)), y = PC2)) +
  geom_bar(stat = "identity", fill = "darkorange") +
  coord_flip() +
  labs(title = "Contribución de variables a PC2", x = "Variable", y = "Peso (loading)")



```
```{r}
#### PCA and clustering analysis

# Select numeric variables only
numeric_vars <- data_rec %>%
  select(where(is.numeric)) %>%
  na.omit()

# Standardize
numeric_scaled <- scale(numeric_vars)

# PCA
pca_res <- prcomp(numeric_scaled, center = TRUE, scale. = TRUE)

# Scree plot (eigenvalues)
plot(pca_res, type = "l", main = "Scree plot of eigenvalues")

# Variance explained
summary(pca_res)

# Variable contributions (loadings)
loadings <- pca_res$rotation
print(loadings[,1:3])  # contributions to first 3 PCs

# Clustering on PCA scores
set.seed(123)
pca_scores <- pca_res$x[,1:2]  # first 2 PCs
km_res <- kmeans(pca_scores, centers = 3, nstart = 25)

# Plot clusters
plot(pca_scores, col = km_res$cluster,
     main = "Clustering on PCA (PC1 vs PC2)")
points(km_res$centers, col = 1:3, pch = 8, cex = 2)

# Prepare PCA scores as a data frame
pca_scores_df <- as.data.frame(pca_scores)
pca_scores_df$cluster <- factor(km_res$cluster)

# Add death status (assuming 'recidiva_exitus' indicates death: 1 = death, 0 = alive)
pca_scores_df$death_status <- factor(data_rec$recidiva_exitus,
                                     levels = c(0,1),
                                     labels = c("Alive","Deceased"))

# PCA plot with clusters and death status
ggplot(pca_scores_df, aes(x = PC1, y = PC2, color = cluster, shape = death_status)) +
  geom_point(size = 3, alpha = 0.8) +
  geom_point(data = as.data.frame(km_res$centers), 
             aes(x = PC1, y = PC2),
             color = 1:3, shape = 8, size = 4) +
  labs(title = "K-means Clustering on PCA (PC1 vs PC2) with Death Status",
       color = "Cluster",
       shape = "Death Status") +
  theme_minimal() +
  theme(text = element_text(size = 12))

table(pca_scores_df$cluster, data_rec$recidiva_bin)

```


```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(FactoMineR)
library(factoextra)

# 1. Selecciona solo las variables significativas que quieres conservar
# Ejemplo usando nombres de tus variables significativas
vars_sig <- c("Grado", "libre_enferm", "beta_cateninap", "mlh1", 
              "grupo_de_riesgo_definitivo", "Tributaria_a_Radioterapia",
              "afectacion_linf", "grado_histologi", "AP_centinela_pelvico",
              "AP_ganPelv", "tipo_histologico_collapsed")

data_sig <- data_rec %>%
  select(all_of(vars_sig))

# 2. Convierte las variables categóricas en factores (si no lo son)
data_sig <- data_sig %>% mutate(across(where(is.character), as.factor))

# 3. Imputa valores faltantes (opcional, PCA no puede manejar NAs)
# Aquí se reemplaza NA por "Missing" en factores
data_sig <- data_sig %>% mutate(across(where(is.factor), ~addNA(.)))

# 4. Usar PCA con variables mixtas (numéricas y categóricas)
# FactoMineR::FAMD es ideal para esto
famd_res <- FAMD(data_sig, graph = FALSE)

# 5. Scree plot
fviz_screeplot(famd_res, addlabels = TRUE, ylim = c(0, 50))

# 6. Visualizar variables que más contribuyen a los primeros PCs
fviz_famd_var(famd_res, choice = "var", repel = TRUE)

# 7. Obtener las coordenadas de los individuos (scores)
pca_scores <- famd_res$ind$coord[,1:2]  # primeros 2 PCs

# 8. Clustering (K-means) sobre los scores de PCA
set.seed(123)
km_res <- kmeans(pca_scores, centers = 3, nstart = 25)

# 9. Añadir cluster y estado de muerte para visualización
pca_scores_df <- as.data.frame(pca_scores)
pca_scores_df$cluster <- factor(km_res$cluster)
pca_scores_df$death_status <- factor(data_rec$recidiva_exitus,
                                     levels = c(0,1),
                                     labels = c("Alive","Deceased"))

# 10. Plot PCA con clusters y estado de muerte
ggplot(pca_scores_df, aes(x = Dim.1, y = Dim.2, color = cluster)) +
  geom_point(size = 3, alpha = 0.8) +
  geom_point(data = as.data.frame(km_res$centers), aes(x = Dim.1, y = Dim.2),
             color = 1:3, shape = 8, size = 4) +
  labs(title = "K-means Clustering on PCA (FAMD) with Death Status",
       color = "Cluster") +
  theme_minimal()


```

```{r}
# Check if all deaths were relapses
death_relapse_check <- data_reducido %>%
  filter(recidiva_exitus == 1) %>%
  summarise(
    total_deaths = n(),
    deaths_with_relapse = sum(recidiva == 1, na.rm = TRUE),
    deaths_without_relapse = sum(recidiva == 0, na.rm = TRUE),
    perc_with_relapse = round(100 * deaths_with_relapse / n(), 1)
  )

# Print as list
print(as.list(death_relapse_check))

# Survival rate among relapsed patients
relapse_survival <- data_reducido %>%
  filter(recidiva == 1) %>%
  summarise(
    total_relapsed = n(),
    survived = sum(recidiva_exitus == 0, na.rm = TRUE),
    died = sum(recidiva_exitus == 1, na.rm = TRUE),
    survival_rate = round(100 * survived / n(), 1)
  )

# Print as list
print(as.list(relapse_survival))

```

```{r}
# Define cluster labels
clusters_full <- km_res$cluster

data_rec <- data_rec %>%
  mutate(cluster = factor(clusters_full),
         cluster_label = case_when(
           cluster == 1 ~ "Buen pronóstico",
           cluster == 2 ~ "Alto riesgo",
           cluster == 3 ~ "Mixto"
         ))

# Variables of interest
vars_sig <- c("Grado", "libre_enferm", "beta_cateninap", "mlh1", 
              "grupo_de_riesgo_definitivo", "Tributaria_a_Radioterapia",
              "afectacion_linf", "grado_histologi", "AP_centinela_pelvico",
              "AP_ganPelv", "tipo_histologico")

# Prepare dataset for cluster summaries
data_sig_cluster <- data_rec %>%
  select(cluster, cluster_label, recidiva, all_of(vars_sig))

cluster_summary <- data_sig_cluster %>%
  mutate(across(-c(cluster, cluster_label, recidiva), as.factor)) %>%
  pivot_longer(-c(cluster, cluster_label, recidiva),
               names_to = "variable", values_to = "value") %>%
  group_by(cluster, cluster_label, recidiva, variable, value) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(cluster, cluster_label, recidiva, variable) %>%
  mutate(freq = n / sum(n)) %>%
  arrange(cluster, variable, desc(freq))

# Labels for variables
labels_vars <- c(
  "afectacion_linf" = "Afectación linfática",
  "AP_centinela_pelvico" = "AP centinela pélvico",
  "AP_ganPelv" = "AP ganglio pélvico",
  "beta_cateninap" = "Beta-catenina",
  "Grado" = "Grado tumoral",
  "grado_histologi" = "Grado histológico",
  "grupo_de_riesgo_definitivo" = "Grupo de riesgo",
  "libre_enferm" = "Libre de enfermedad",
  "mlh1" = "MLH1",
  "tipo_histologico" = "Tipo histológico",
  "Tributaria_a_Radioterapia" = "Radioterapia"
)

# --- Add relapse/death summary text ---
summary_text <- paste0(
  "Total deaths: 27 | Deaths with relapse: 11 | Deaths without relapse: 16 (40.7%)\n",
  "Total relapsed: 29 | Survived: 18 | Died: 11 | Survival rate after relapse: 62.1%"
)

# Heatmap for recurrence
ggplot(cluster_summary %>% filter(recidiva == 1),
       aes(x = variable, y = cluster_label, fill = freq)) +
  geom_tile(color = "black") +
  scale_fill_gradient(low = "white", high = "#DB0B00", name = "Proporción") +
  scale_x_discrete(labels = labels_vars) +
  facet_wrap(~recidiva,
             labeller = labeller(recidiva = c("0" = "Sin recidiva", "1" = "Con recidiva"))) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Distribución de variables en pacientes por cluster y recidiva",
       x = "Variable",
       y = "Cluster",
       caption = summary_text)   # <-- annotation added here

# Heatmap for non-recurrence
ggplot(cluster_summary %>% filter(recidiva == 0),
       aes(x = variable, y = cluster_label, fill = freq)) +
  geom_tile(color = "black") +
  scale_fill_gradient(low = "white", high = "#DB0B00", name = "Proporción") +
  scale_x_discrete(labels = labels_vars) +
  facet_wrap(~recidiva,
             labeller = labeller(recidiva = c("0" = "Sin recidiva", "1" = "Con recidiva"))) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Distribución de variables en pacientes por cluster y sin recidiva",
       x = "Variable",
       y = "Cluster",
       caption = summary_text)   # <-- annotation added here
```

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# 1. Subset: patients with no relapse
non_relapsed <- data_rec %>%
  filter(recidiva == 0)

# 2. Variables of interest
vars_sig <- c("Grado", "libre_enferm", "beta_cateninap", "mlh1",
              "grupo_de_riesgo_definitivo", "Tributaria_a_Radioterapia",
              "afectacion_linf", "grado_histologi", "AP_centinela_pelvico",
              "AP_ganPelv", "tipo_histologico")

# 3. Prepare summary frequencies by cluster and death status
heatmap_data <- non_relapsed %>%
  select(cluster, cluster_label, recidiva_exitus, all_of(vars_sig)) %>%
  mutate(death_status = ifelse(recidiva_exitus == 1, "Muertos", "Vivos")) %>%
  mutate(across(all_of(vars_sig), as.factor)) %>%
  pivot_longer(cols = all_of(vars_sig), names_to = "variable", values_to = "value") %>%
  group_by(cluster_label, death_status, variable, value) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(cluster_label, death_status, variable) %>%
  mutate(freq = n / sum(n))

# 4. Separate datasets for vivos and muertos
heatmap_vivos <- heatmap_data %>% filter(death_status == "Vivos")
heatmap_muertos <- heatmap_data %>% filter(death_status == "Muertos")

#5. Nombres eje Y
labels_vars <- c(
  "afectacion_linf" = "Afectació limfàtica",
  "AP_centinela_pelvico" = "AP centinela pèlvic",
  "AP_ganPelv" = "AP gangli pèlvic",
  "beta_cateninap" = "Beta-catenina",
  "Grado" = "Grau tumoral",
  "grado_histologi" = "Grau histològic",
  "grupo_de_riesgo_definitivo" = "Grup de risc",
  "libre_enferm" = "Lliure de malaltia",
  "mlh1" = "MLH1",
  "tipo_histologico" = "Tipus histològico",
  "Tributaria_a_Radioterapia" = "Radioteràpia"
)

# 6. Heatmap vivos (verde)
ggplot(heatmap_vivos, aes(x = cluster_label, y = variable, fill = freq)) +
  geom_tile(color = "black") +
  scale_fill_gradient(low = "white", high = "#00C040", name = "Proporción") +
  scale_y_discrete(labels=labels_vars) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text.y = element_text(angle = 0)) +
  labs(title = "Pacients vius amb pacients no recessiva",
       x = "Cluster",
       y = "Variable")

# 7. Heatmap muertos (rojo)
ggplot(heatmap_muertos, aes(x = cluster_label, y = variable, fill = freq)) +
  geom_tile(color = "black") +
  scale_fill_gradient(low = "white", high = "#DB0B00", name = "Proporción") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text.y = element_blank()) +  # opcional:ocultar nombres de variables
  labs(title = "Pacients morts amb pacients no recessiu",
       x = "Cluster",
       y = "")

```

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# 1. Subset: patients with no relapse
non_relapsed <- data_rec %>%
  filter(recidiva == 1)

# 2. Variables of interest
vars_sig <- c("Grado", "libre_enferm", "beta_cateninap", "mlh1",
              "grupo_de_riesgo_definitivo", "Tributaria_a_Radioterapia",
              "afectacion_linf", "grado_histologi", "AP_centinela_pelvico",
              "AP_ganPelv", "tipo_histologico")


# 3. Prepare summary frequencies by cluster and death status
heatmap_data <- non_relapsed %>%
  select(cluster, cluster_label, recidiva_exitus, all_of(vars_sig)) %>%
  mutate(death_status = ifelse(recidiva_exitus == 1, "Muertos", "Vivos")) %>%
  mutate(across(all_of(vars_sig), as.factor)) %>%
  pivot_longer(cols = all_of(vars_sig), names_to = "variable", values_to = "value") %>%
  group_by(cluster_label, death_status, variable, value) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(cluster_label, death_status, variable) %>%
  mutate(freq = n / sum(n))

# 4. Separate datasets for vivos and muertos
heatmap_vivos <- heatmap_data %>% filter(death_status == "Vivos")
heatmap_muertos <- heatmap_data %>% filter(death_status == "Muertos")

# 5. Nombres 
labels_vars <- c(
  "afectacion_linf" = "Afectació limfàtica",
  "AP_centinela_pelvico" = "AP centinela pèlvic",
  "AP_ganPelv" = "AP gangli pèlvic",
  "beta_cateninap" = "Beta-catenina",
  "Grado" = "Grau tumoral",
  "grado_histologi" = "Grau histològic",
  "grupo_de_riesgo_definitivo" = "Grup de risc",
  "libre_enferm" = "Lliure de malaltia",
  "mlh1" = "MLH1",
  "tipo_histologico" = "Tipus histològico",
  "Tributaria_a_Radioterapia" = "Radioteràpia"
)

# 5. Heatmap vivos (verde)
ggplot(heatmap_vivos, aes(x = cluster_label, y = variable, fill = freq)) +
  geom_tile(color = "black") +
  scale_fill_gradient(low = "white", high = "#00C040", name = "Proporció") +
  scale_y_discrete(labels=labels_vars) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text.y = element_text(angle = 0)) +
  labs(title = "Pacients vius amb pacients no recessiva",
       x = "Cluster",
       y = "Variable")

# 6. Heatmap muertos (rojo)
ggplot(heatmap_muertos, aes(x = cluster_label, y = variable, fill = freq)) +
  geom_tile(color = "black") +
  scale_fill_gradient(low = "white", high = "#DB0B00", name = "Proporció") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text.y = element_blank()) +  # opcional: ocultar nombres de variables
  labs(title = "Pacients morts amb pacients no recessiva",
       x = "Cluster",
       y = "")
```

```{r}
library(dplyr)
library(tidyr)

vars_sig <- c("Grado","libre_enferm","beta_cateninap","mlh1",
              "grupo_de_riesgo_definitivo","Tributaria_a_Radioterapia",
              "afectacion_linf","grado_histologi","AP_centinela_pelvico",
              "AP_ganPelv","tipo_histologico")

empirical_results <- list()

for (var in vars_sig) {
  df <- data_rec %>%
    group_by(.data[[var]], cluster_label) %>%
    summarise(n = n(), .groups = "drop") %>%
    group_by(.data[[var]]) %>%
    mutate(prob = round(100 * n / sum(n), 1),
           variable = var) %>%
    # Force values to character so bind_rows works
    mutate(value = as.character(.data[[var]])) %>%
    select(variable, value, cluster_label, prob)
  
  empirical_results[[var]] <- df
}

# Combine into one dataframe
empirical_summary <- bind_rows(empirical_results)

# Pivot wider: cluster probabilities side by side
empirical_summary_wide <- empirical_summary %>%
  pivot_wider(names_from = cluster_label, values_from = prob)

print(empirical_summary_wide)

```
```{r}
library(dplyr)

score_new_patient <- function(new_patient, empirical_table, cluster_cols) {
  
  # Ensure input is one-row dataframe
  stopifnot(nrow(new_patient) == 1)
  
  scores <- empirical_table %>%
    filter(
      variable %in% names(new_patient)
    ) %>%
    rowwise() %>%
    mutate(
      match = as.character(new_patient[[variable]]) == value
    ) %>%
    ungroup() %>%
    filter(match)
  
  # Aggregate cluster probabilities
  result <- scores %>%
    summarise(
      across(all_of(cluster_cols), ~ mean(.x, na.rm = TRUE))
    )
  
  # Normalize to 100%
  result <- result %>%
    mutate(
      total = rowSums(across(all_of(cluster_cols))),
      across(all_of(cluster_cols), ~ round(100 * .x / total, 1))
    ) %>%
    select(-total)
  
  return(result)
}

```

```{r}
new_patient <- data.frame(
  Grado = "Alto",
  libre_enferm = "No",
  beta_cateninap = "1",
  mlh1 = "0",
  grupo_de_riesgo_definitivo = "Alto",
  Tributaria_a_Radioterapia = "Si",
  afectacion_linf = "Si",
  grado_histologi = "Alto",
  AP_centinela_pelvico = "pN1",
  AP_ganPelv = "Macrometastasis",
  tipo_histologico = "2",
  stringsAsFactors = FALSE
)

cluster_columns <- c("Alto riesgo", "Buen pronóstico", "Mixto")

score_new_patient(
  new_patient = new_patient,
  empirical_table = empirical_summary_wide,
  cluster_cols = cluster_columns
)

```

```{r}
library(dplyr)

score_new_patient <- function(new_patient, empirical_table, cluster_cols) {
  
  # Ensure input is one-row dataframe
  stopifnot(nrow(new_patient) == 1)
  
  scores <- empirical_table %>%
    filter(
      variable %in% names(new_patient)
    ) %>%
    rowwise() %>%
    mutate(
      match = as.character(new_patient[[variable]]) == value
    ) %>%
    ungroup() %>%
    filter(match)
  
  # Aggregate cluster probabilities
  result <- scores %>%
    summarise(
      across(all_of(cluster_cols), ~ mean(.x, na.rm = TRUE))
    )
  
  # Normalize to 100%
  result <- result %>%
    mutate(
      total = rowSums(across(all_of(cluster_cols))),
      across(all_of(cluster_cols), ~ round(100 * .x / total, 1))
    )
  
  # Drop the helper column safely
  result$total <- NULL
  
  return(result)
}

```

```{r}
new_patient <- data.frame(
  Grado = "Alto",
  libre_enferm = "No",
  beta_cateninap = "1",
  mlh1 = "0",
  grupo_de_riesgo_definitivo = "Alto",
  Tributaria_a_Radioterapia = "Si",
  afectacion_linf = "Si",
  grado_histologi = "Alto",
  AP_centinela_pelvico = "pN1",
  AP_ganPelv = "Macrometastasis",
  tipo_histologico = "2",
  stringsAsFactors = FALSE
)

cluster_columns <- c("Alto riesgo", "Buen pronóstico", "Mixto")

score_new_patient(
  new_patient = new_patient,
  empirical_table = empirical_summary_wide,
  cluster_cols = cluster_columns
)

```
```{r}
library(dplyr)
library(lubridate)

# Compute relapse time (days) from dataset
compute_relapse_time <- function(data_rec,
                                 surgery_col = "fecha_qx",
                                 relapse_flag_col = "dx_recidiva",
                                 followup_col = "Ultima_fecha",
                                 date_format_surgery = "%d/%m/%Y") {
  df <- data_rec %>%
    mutate(
      # Parse surgery date (dd/mm/yyyy)
      surgery_date  = as.Date(.data[[surgery_col]], format = date_format_surgery),
      # Parse follow-up date (strip " UTC" if present)
      followup_date = as.Date(gsub(" UTC","",.data[[followup_col]])),
      # Event indicator: relapse_flag == 1
      relapse_event = !is.na(.data[[relapse_flag_col]]) & .data[[relapse_flag_col]] == 1,
      # Time-to-event (days): always follow-up minus surgery
      tte_days = as.numeric(followup_date - surgery_date)
    )
  df
}

# Summarize relapse days by cluster
summarize_relapse_by_cluster <- function(df, cluster_col = "cluster_label",
                                         stat = c("median","mean")) {
  stat <- match.arg(stat)
  df %>%
    filter(relapse_event, !is.na(.data[[cluster_col]]), !is.na(tte_days), tte_days >= 0) %>%
    group_by(.data[[cluster_col]]) %>%
    summarise(
      n_events = n(),
      days_median = median(tte_days),
      days_mean   = mean(tte_days),
      .groups = "drop"
    ) %>%
    mutate(relapse_days = if (stat == "median") days_median else days_mean)
}

# Combine cluster probabilities with relapse times
combine_probs_to_days <- function(probs_named, cluster_stats,
                                  cluster_map = c("Alto riesgo" = "Alto riesgo",
                                                  "Buen pronóstico" = "Buen pronóstico",
                                                  "Mixto" = "Mixto"),
                                  probs_in_percent = TRUE) {
  p <- probs_named
  if (probs_in_percent) p <- p / 100
  combo <- tibble(
    prob_name   = names(p),
    prob_value  = as.numeric(p),
    cluster_lab = unname(cluster_map[prob_name])
  ) %>%
    left_join(cluster_stats %>% dplyr::select(cluster_label, relapse_days),
              by = c("cluster_lab" = "cluster_label")) %>%
    filter(!is.na(relapse_days), !is.na(prob_value))
  if (nrow(combo) == 0) return(NA_real_)
  sum(combo$prob_value * combo$relapse_days) / sum(combo$prob_value)
}

# Wrapper: predict days + date
predict_relapse_days <- function(new_patient_df,
                                 empirical_table,
                                 cluster_cols = c("Alto riesgo","Buen pronóstico","Mixto"),
                                 data_rec,
                                 surgery_date = Sys.Date(),
                                 cluster_col = "cluster_label",
                                 stat = c("median","mean")) {
  stat <- match.arg(stat)
  probs_tbl <- score_new_patient(new_patient_df, empirical_table, cluster_cols)
  if (nrow(probs_tbl) == 0 || anyNA(probs_tbl[cluster_cols])) {
    return(list(pred_days = NA_real_, pred_date = as.Date(NA)))
  }
  probs_named <- c(
    `Alto riesgo` = probs_tbl$`Alto riesgo`,
    `Buen pronóstico` = probs_tbl$`Buen pronóstico`,
    `Mixto` = probs_tbl$Mixto
  )
  df_tte <- compute_relapse_time(data_rec)
  cl_stats <- summarize_relapse_by_cluster(df_tte, cluster_col = cluster_col, stat = stat)
  pred_days <- combine_probs_to_days(probs_named, cl_stats, probs_in_percent = TRUE)
  pred_date <- if (!is.na(pred_days)) as.Date(surgery_date) + round(pred_days) else as.Date(NA)
  list(pred_days = pred_days, pred_date = pred_date,
       probs = probs_named, cluster_stats = cl_stats)
}

```

```{r}
# Patient variables (input)
new_patient <- data.frame(
  Grado = "Alto",
  libre_enferm = "No",
  beta_cateninap = "1",
  mlh1 = "0",
  grupo_de_riesgo_definitivo = "Alto",
  Tributaria_a_Radioterapia = "Si",
  afectacion_linf = "Si",
  grado_histologi = "Alto",
  AP_centinela_pelvico = "pN1",
  AP_ganPelv = "Macrometastasis",
  tipo_histologico = "2",
  stringsAsFactors = FALSE
)

cluster_columns <- c("Alto riesgo","Buen pronóstico","Mixto")

# Run prediction with chosen surgery date
pred <- predict_relapse_days(
  new_patient_df = new_patient,
  empirical_table = empirical_summary_wide,
  cluster_cols = cluster_columns,
  data_rec = data_rec,
  surgery_date = as.Date(Sys.Date(), format="%d/%m/%Y"),  # input date
  cluster_col = "cluster_label",
  stat = "median"
)

# Format output
pred_days <- round(pred$pred_days)
pred_date <- format(pred$pred_date, "%d/%m/%Y")

cat("Predicted days to relapse:", pred_days, "\n")
cat("Predicted relapse date:", pred_date, "\n")

```

